*** notes on 9/14/2015
1. I am studying how to run collision detection on particle systems. So far it seems that there is nothing good!
2. I am studying raycasters in three.js
3. I am changing the createContainer() function to createBox() function, the main change is that I am creating a 3D box instead of a 2D rectangle.
	And instead of actually drawing the box, I am creating a MESH using BoxGeometry(). 
	I also need to set the position and rotate the box so that it matches the coordinates of the input json object
4. I also am changing the start and end point objects to a bunch of Vector3() objects, I think this make thins easier later.
5. I made the component box transparent by adding:
	boxMaterial.transparent = true;
	boxMaterial.opacity = 0.5;
	But it did not work and it did not show the particles inside the box. I searched and added this line, which solved the problem:
	boxMaterial.depthWrite = false;
	
*** notes on 9/15/2015
1. Now it's time to work on collision detection!
2. Can I use boundingBox? 
	boundingBox = new THREE.Box3().setFromObject(boxMesh);
3. No! boundingBox is not the answer, because the box is parallel to the XYZ axes. 
4. I should define walls and use collision detection to the walls.

*** notes on 9/16/2015
1. Trying to rotate a geometry around a point that is external to the geometry --> to rotate the walls of component
	the solution is to append the walls to the component as its children and then rotate all of them at once
	component.add(walls[i]);
2. Now dealing with the raycaster and collision	
	For each electron I need to build a raycaster with electron's position and direction of moving, which is basically it's velocity vector.
3. For now, the electrons move randomly inside the box.
4. I made all the electrons moving with the same initial velocity, by changing random velocity.y to a value that results in a constant velocity 
	( velocity.y = sqrt(velocity-velocity.x^2) )
5. Now it's time to import the components from parse json object.

ADD LATER: change the bouncing off the walls
ADD LATER: add bumping into the ions!

*** notes on 9/16/2015
1. I added the code from old code that passes the json object of components to the webgl. I needed to make some little modifications in the code,
	including moving the js code from html file to the top of my main code. 
2. There are issues with when the parse code is called, which I'll fix later.
3. I fixed the problem with the coordinates, changing the code in "Circuit.dart" file, where it sends the json object.
	Before it was scaled to match the webgl format, but now I want the real position according to the center of working box.
4. ISSUE: not generating ions (SOLVED).
5. ISSUE: the component is rotated 90 degree on the XY plane (SOLVED).
6. ISSUE: the code stops when I change the circuit, any change (SOLVED).

*** notes on 9/17/2015
1. working on parsing code. Things to fix:
	* XY coordinates are not correct
	* run parse first, before making a change in the circuit.
	* there are no ions in the system now 
	* the code stops after making one change
2. I don't know what this is for: SyntaxError: unreachable code after return statement

*** notes on 9/21/2015
1. Today, I am trying to figure out how data streaming works in pubnub and parse.
2. I updated the JS Parse source, but then the execution gives error that Parse is not defined! I changed it back to the old one for now, to fix it later!
	For now, don't use the latest source!
3. I studies all the details about data streaming.
4. I created my own pubnub channel, and my own Parse app with my own account! All understood from Mmachi's code!
5. The components were not rotated by 90 degrees, the XY coordinates were set wrongly, which I fixed. Right now, the input coordinates in webgl are scaled up by x2
6. Warning Message: THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.
	---> NOT an issue for now, IGNORE it.
7. The issue with ions is solved. The issue was not with not generating ions, but with some scaling issue in the code that resulted in no ion to generate.

*** notes on 9/22/2015
1. Today, I am working on the issue that code stops rendering after I update the circuit. I am reading about requestAnimationFrame() method and how renderer works in WebGL.
2. I think at each update, I only need to remove objects from the scene, and add new objects to the scene.
3. YESSSSS! IT WORKED:
	I just needed to write an update() function, which only removes scene children and adds the updated objects to the scene.
4. ISSUE: with each update, electrons speed up!
5. ISSUE: it is still not rendering correctly, some objects don't update correctly, some particles remain on canvas after the update, etc. 
	(SOLVED)
	Explanation: it was not corretcly removing the scene children, I used a wrong for loop.
	stackoverflow link that helped: http://stackoverflow.com/questions/29417374/threejs-remove-all-together-object-from-scene

6. I am working on camera, Z coordinate, and zooming in and zooming out
	I found a code online and added to my code, and now by mouse wheel, it zooms in/out.
	I used this link: http://stackoverflow.com/questions/10354574/webgl-zooming-camera-in-threejs-without-trackball-controls-or-other-camera-con
	ISSUE: when it zooms in as much that the objects are out of scene, it cannot zoom out anymore!
	

	
	

