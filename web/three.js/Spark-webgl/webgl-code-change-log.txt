THINGS TO FIX LATER:
1. [3/31/2016] why when the obstacles are disabled, the electrons only move to up, and not down?! fix this later
2. [3/31/2016] I cannot use the camer on chrome, ask Mike to help you with this so that I can migrate back from firefox to chrome
3. [3/31/2016] fix this error: TypeError: components[electron.componentID] is undefined
			   everytime that the circuit is updated it gives this error before the components are updated, the code performs correctly
			   but this error needs to be fixed later
4. [3/31/2016] 			   


*** notes on 9/14/2015
1. I am studying how to run collision detection on particle systems. So far it seems that there is nothing good!
2. I am studying raycasters in three.js
3. I am changing the createContainer() function to createBox() function, the main change is that I am creating a 3D box instead of a 2D rectangle.
	And instead of actually drawing the box, I am creating a MESH using BoxGeometry(). 
	I also need to set the position and rotate the box so that it matches the coordinates of the input json object
4. I also am changing the start and end point objects to a bunch of Vector3() objects, I think this make thins easier later.
5. I made the component box transparent by adding:
	boxMaterial.transparent = true;
	boxMaterial.opacity = 0.5;
	But it did not work and it did not show the particles inside the box. I searched and added this line, which solved the problem:
	boxMaterial.depthWrite = false;
	
*** notes on 9/15/2015
1. Now it's time to work on collision detection!
2. Can I use boundingBox? 
	boundingBox = new THREE.Box3().setFromObject(boxMesh);
3. No! boundingBox is not the answer, because the box is parallel to the XYZ axes. 
4. I should define walls and use collision detection to the walls.

*** notes on 9/16/2015
1. Trying to rotate a geometry around a point that is external to the geometry --> to rotate the walls of component
	the solution is to append the walls to the component as its children and then rotate all of them at once
	component.add(walls[i]);
2. Now dealing with the raycaster and collision	
	For each electron I need to build a raycaster with electron's position and direction of moving, which is basically it's velocity vector.
3. For now, the electrons move randomly inside the box.
4. I made all the electrons moving with the same initial velocity, by changing random velocity.y to a value that results in a constant velocity 
	( velocity.y = sqrt(velocity-velocity.x^2) )
5. Now it's time to import the components from parse json object.

ADD LATER: change the bouncing off the walls
ADD LATER: add bumping into the ions!

*** notes on 9/16/2015
1. I added the code from old code that passes the json object of components to the webgl. I needed to make some little modifications in the code,
	including moving the js code from html file to the top of my main code. 
2. There are issues with when the parse code is called, which I'll fix later.
3. I fixed the problem with the coordinates, changing the code in "Circuit.dart" file, where it sends the json object.
	Before it was scaled to match the webgl format, but now I want the real position according to the center of working box.
4. ISSUE: not generating ions (SOLVED).
5. ISSUE: the component is rotated 90 degree on the XY plane (SOLVED).
6. ISSUE: the code stops when I change the circuit, any change (SOLVED).

*** notes on 9/17/2015
1. working on parsing code. Things to fix:
	* XY coordinates are not correct
	* run parse first, before making a change in the circuit.
	* there are no ions in the system now 
	* the code stops after making one change
2. I don't know what this is for: SyntaxError: unreachable code after return statement

*** notes on 9/21/2015
1. Today, I am trying to figure out how data streaming works in pubnub and parse.
2. I updated the JS Parse source, but then the execution gives error that Parse is not defined! I changed it back to the old one for now, to fix it later!
	For now, don't use the latest source!
3. I studies all the details about data streaming.
4. I created my own pubnub channel, and my own Parse app with my own account! All understood from Mmachi's code!
5. The components were not rotated by 90 degrees, the XY coordinates were set wrongly, which I fixed. Right now, the input coordinates in webgl are scaled up by x2
6. Warning Message: THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.
	---> NOT an issue for now, IGNORE it.
7. The issue with ions is solved. The issue was not with not generating ions, but with some scaling issue in the code that resulted in no ion to generate.

*** notes on 9/22/2015
1. Today, I am working on the issue that code stops rendering after I update the circuit. I am reading about requestAnimationFrame() method and how renderer works in WebGL.
2. I think at each update, I only need to remove objects from the scene, and add new objects to the scene.
3. YESSSSS! IT WORKED:
	I just needed to write an update() function, which only removes scene children and adds the updated objects to the scene.
4. ISSUE: with each update, electrons speed up! (SOLVED)
5. ISSUE: it is still not rendering correctly, some objects don't update correctly, some particles remain on canvas after the update, etc. 
	(SOLVED)
	Explanation: it was not corretcly removing the scene children, I used a wrong for loop.
	stackoverflow link that helped: http://stackoverflow.com/questions/29417374/threejs-remove-all-together-object-from-scene

6. I am working on camera, Z coordinate, and zooming in and zooming out
	I found a code online and added to my code, and now by mouse wheel, it zooms in/out.
	I used this link: http://stackoverflow.com/questions/10354574/webgl-zooming-camera-in-threejs-without-trackball-controls-or-other-camera-con
ISSUE: when it zooms in as much that the objects are out of scene, it cannot zoom out anymore!

*** notes on 9/23/2015
1. Solved the problem with electrons speeding up:
	Apparently, at each time that it was calling requestAnimationFrame( animate ), it was changing the time interval or something, 
	and as a result it was moving the particles faster (i.e., each update resulted in a shorter time step, and hence a faster particle)
	Solution was to only call render() function at each update, and not the whole animate() function.
2. I added a mouse drag functionality, by adding mouse up, mouse move, and mouse down functions. It now rotates the camera
	I originally wanted the mouse drag to drag the scene but it need more work later.
3. Working on collision with ions.
4. It seems that I have to change ions from being a particle system to an array of regular objects. It seems impossible to add the collision function if ions are particles.
	i.e., the raycaster only works with object3 structures, and the individual particles are not objects!
5. I changed the ion structure to become an array of ions as children of each component, so they are not pointcloud structure anymore.

*** notes on 9/24/2015
1. I studies how I can draw spheres for electrons, instead of using a ball texture. I haven't changed the code yet, but this link seems to show some good tricks, check it later:
http://stackoverflow.com/questions/12372834/rendering-spheres-or-points-in-a-particle-system
2. I added collision with ions
3. I added a tiny randomness in the bouncing back direction, but it still needs more work
4. I added a battery image texture to the battery and wrote a separate function for initializing the battery.
	
*** notes on 9/29/2015
1. Mike suggested that I don't use slice() method to select the electrons for each component (for the updateElectrons function).
	He thinks each time slice() is called, maybe it copies a whole array which can significantly slows down the execution. 
	Instead, I can pass the whole electrons array with start and end index to the updateElectron function.
	I did that, but I am not sure if I seen any obvious change in the speed of electrons moving.
2. I changed the structue of code, in a way that instead of assigning arrays of electrons to components in order, I create an ID field for each electron,
	which says which component it belongs to. This will make moving from one component to another easier later on.
	
*** notes on 9/30/2015	
1. Next project: Add junctions!
2. To avoid electrons flying off the component at reset: 
	I added a constant 5 to the calculated init coordination of electrons to avoid creating electrons right on the edge.
3. I also made the ion layout look a bit better!

*** notes on 10/6/2015
1. Since last week the code started crashing! Mike helped me run the code on Chrome using local server 127.0.0.1:3030
	But still the code crashes.
2. I am now trying to debug the issue. First, the crash was due to initing the code with two components initiated in the code
	and then when I update the circuit with Parse and data streaming, for some reason it crashes the code. 
	So for now, I commented the testing components and it directly initiates the circuit that is streamed from Parse.
3. Still the problem with updating speed is not solved. I submitted the code to gitub and am trying to compare it to the last commint to detect the source of issue.
4. I went through the code step by step and found out that the part that creates ions slows down the execution!!!
	*** the problem was that at each run of for loop for creating ions, the ionGeometry and ionMaterial were initialized too. 
		I movet it out of the loop, and the problem was solved :)
5. I fixed bouncing back code, using the face and normal property of the raycaster. The code is fixed for the ions, but still does not work for bouncing off the walls
	
*** notes on 10/7/2015
1. For some reason, bouncing back from the ions dramatically slows down the electrons. I need to troubleshoot it and find why! 	
	It also seems that the slowed down electron does not bounce off the ions anymore! (actually it is not always the case)
	Answer: the reflection is not working right. after bouncing back the z component of the velocity vector is not zero anymore, this explains both above observations!
2. ISSUE: the new bouncing back code still does not work for the walls, for some reason it detects a wrong face with a normal in z direction.
3. Now I am working on constructing a json object to send the information about connected components.
jsify():
https://api.dartlang.org/1.12.1/dart-js/JsObject/JsObject.jsify.html
create JSON by JS for loop:
http://stackoverflow.com/questions/920930/how-to-create-json-by-javascript-for-loop
4. I finished making the matrix in the dart code. the matrix encodes information about what components are connected and how (from s to e, from s to s, etc.)

*** notes on 10/8/2015
1. I need to flatten the connections array sent from Parse to the JS code.
Link to how to flatten a nested array: http://www.christopherbiscardi.com/2014/01/06/flattening-nested-arrays-in-javascript/
2. ISSUE: fix the bug with removing connected components!
3. ISSUE: fix the bug with reset button in Dart: not showing the battery when it is reset.
4. ISSUE: bouncing off the walls not working!


*** notes on 10/14/2015
Working on the Dart code to fix old issues (check dart code change log file)

*** notes on 10/15/2015
1. I tried to fix the issue with bouncing off the walls, apparently rotation the walls initially made the normal vectors working not as wanted
	(I still don't understand what is going on!!)
	But there is still issue with bouncing off the walls when the component is angled.
2. I modified bouncing off the ions, so that it considers the cases where the angle between electron velocity and normal vector is 180 or 90 degrees
	But still there are a rare cases where the electron stops moving when collide with an ion
	--> needs to be fixed!
	
*** notes on 10/19/2015
1. I have been working on the bounce back function which was not working correctly.
	The problem was with the local space and world space. For example, the electron velocity was in world space,
	but the face normals where in local space. The solution was to rotate the electron velocity with the reverse angle of component rotationAngle
	which makes the electron velocity in the component space, and then calculating the bounce back angle.
	
2. I commented the type check in the parse code, because it sorted the components base on types and then rendered them
	which messed up with reading the connected components!

*** notes on 10/22/2015
1. Working on making the junctions!
2. I wanted to have the electrons bounce off the box from inside. I searched and found this link helpful:
http://stackoverflow.com/questions/28664904/three-js-raycaster-collision-inside-of-cylinder
	The problem is solved by chanding the side of box to be rendered from front to back.
	
*** notes on 10/28/2015
1. I am working on the CSG code, and how to create a union geometry for the whole circuit.
(Note: I tried the three.js merge() function, but it seems that the merging function does not do what I am looking for,
and the edges that each indivudal box has still exists after merging)
2. I also tried to add an orbitcontrols.js library, mimicking a CSG example, but it does not function, I will fix it after I finish the CSG code!
3. I fixed the controls; I just needed to use the source code (OrbitControls.js) from examples library, instead of copying it from the online example resource. 
4. The CSG code is now partially working; I added a union shape, but when the ions are added to the obstacles array it becomes very slow.
	Also, electrons get trapped on some of the union geometry walls, I need to understand why!
	
*** notes on 11/6/2015
1. I am modifying the CSG code, the current main issues are:
	a. when I have a combined mesh with a rotated wire, something wrong goes on with the face normal calculations and it causes some electrons to stop!
	b. I need to add a code that electrons know to which component they belong at each tick, 
	right now they always belong to the component they initiated from 	
	c. the code does not distinguish that the components are actually "connected"! It simply creates a combined mesh no matter what! [FIXED]
	
	
*** notes on 1/1/2016
1. Working on sending the connected graph information to parse and webgl code:
	in circuit.dart code, each graph node knows which connected graph it belongs to. That should be all I need!
	update: for now, I decided to only send the graphLabel information. I figured that sending the connected components information might not be 
	necessary.
2. I changed the CSG code to consider the connected graphs. Now, there is one CSG composite mesh for each of the connected graphs
	And instead of having one big obstacle for all the electrons, now only the composite mesh that the electron belongs to is the obstacle
3. ISSUE: why when two components with no angles are connected, there is a tiny partial wall between them that the electrons bounce off!? 	
	(I should add a sphere junction anyways)
4. ISSUE: angled connected components --> some electrons stop moving at the edges. Is it because they pass the boundary of mesh?	

*** notes on 1/2/2016
1. I am adding sphere junctions to the components.
	It seems that I need to merge the box mesh with the two sphere juctions (instead of adding the two as the children of boxMesh)
I tried the CSG union function to unite [mesh, start juction, end juction], but there are two problems:
	first, the code initially renders very slowly. I need to figure out why!
	--> I tested different parts of code, and it seems the part that it adds the junctions (especially the end junction) makes it very slow
		I don't understand how this is different from adding another box mesh!!
		SOLVED: it seems that the rendering issue was because I set the sphere width and height segments to 60, 
		I reduced it to 30 and it got much faster!
	second, the junctions' positions are not updates based on the component, and they stay at the origin.

*** notes on 1/3/2016
1. ISSUE: the position of junctions for the CSG code:
	I am trying to use the clone() function to solve the problem, but based on what I read online:
	Mesh.clone() does not clone the Geometry and Material properties.
	http://stackoverflow.com/questions/22360936/will-three-js-object3d-clone-create-a-deep-copy-of-the-geometry
	I am lost! I don't understand why the cloned object cannot update it's matrix world to be the correct one :(
	I tried many tricks, but still not successful!
	PROBLEM SOLVED:
	These are my findings, even though I am not 100% sure if I understood all this weird transformation issues!:
	A. I had to clone the component.
	B. The flag for recursive clone is true (default value is set to true), by component.clone() it also clones the junctions (children)
		BUT, it does not copy the world matrix!
	C. So I need to manually update the world matrix for the junctions, therefore I have to clone() the junctions too,
		to avoid messing up with the possition of the original junctions.
	D. To update the world matrix for the junctions, I used this line of code:
		clonedChild.applyMatrix(components[k].boxMesh.matrixWorld);
	
*** notes on 2/2/2016
1. Have been working on device motion
	for now testing rotation component, trying to make it work for the rotation along the z axis
	I started by reading articles on accelerometer data from JS and different events that handle this in JS
2. I am testing a DeviceOrientationControls JS file I found in the library of three.js, trying to modify that code
	I need to rotate the camera
	

*** notes on 3/9/2016
From the testings, it seemed that using the accelerometer data for detecting the motion is not a good option.
So, we decided to go back to JSARoolkit.
I am currently working on the AR, so far I could add a 3D shape on over a tag.
1. now the goal is to add a particle system to the 3D object
	I added the particle system to the box and it now works
	
*** notes on 3/14/2016
I am working on merging the AR code with my three.js code
Issue: there are issues with updating matrices for components and their junctions, now that I am adding the AR code which needs to 
control the updating matrix process, and therefore it messes with the code and things don't work the way that they should.
These are the steps that I am taking to mitigate this problem:
1. I created an allComponents mesh, which contains all the components as its children, so that helps with the updating issue
Before adding the CSG code, I need to figure out how the camera works, because until now, it seems that I don't understand how to
create a camera object that works properly!
Issue solved: the parameter that I need to play with is the "markerWidth" parameter in the AR code.
Issue: the overlay object (i.e., the circuit) is not a stable image, and it moves a lot even when the marker is held still. 
I need to find a way to remove this visual effect.

2. I am trying to add moving electrons to the code. I updated the three.js library, changed pointcould to points.
there is a problem with the size of electrons, I am playing with the sizeAttenuation property of pointsmaterial...
3. Another issue is with the collision code, which seems not working when the AR works!

*** notes on 4/6/2016
1. I worked around the matrix update happenings in the code. It seems that I need to have one object3D (either allComponentsMesh or scene itself)
	that contains all the objects in the scene, and then disable the matrix auto update for that parent object (e.g. scene.matrixAutoUpdate = false)
	and then I just need to be worried about updating transforming the parent object using the JsAr result matrix. This means that I need to add the 
	electrons to the parent object.
2. Now that the problem is solved, I still need to solve the issue of electrons bouncing off the walls 
ISSUE 1: the bounce back procedure does not work correctly (even with no AR)
		SOLUTION: I fixed it for no AR condition
		for AR condition: the problem is within the collision procedure where I used to update the localVelocity vector by this code:
		localVelocity.applyAxisAngle(new THREE.Vector3(0, 0, -1), this.rotationAngle);
		Now that the matrix is updated by scene matrix update (manually), the rotationAngle would not work any longer!
		Issue: I detected that the problem is not with bouncing back, but one step earlier, the problem is that with AR added, there is no 
		collision reported by the raycaster.
		*** I think I need to play with the updateElectrons procedure, because I realized that everytime the scene matrix is updated by the JsAr
		computations, the electron velocity is still untouched.
	
ISSUE 2: all the electrons move towards positive y coordinate, I need to fix this!	
		SOLVED: adding this line: if ( Math.round(Math.random()) == 1 ) vY *= -1;

3. I added the ions as obstacles, and it is working all fine (a while ago I significantly decreased the width & height segements of the
	spheregeometry)		
	
*** notes on 4/11/2016
1. Today, I am trying to fix the problem with running the code on chrome. Chrome browser worked fine before I added the AR code
but after adding the JsAr code, it gave errors and I had to switch to firefox

NOTE: when using chrome browser I have to use localhost (as a secure origin) 
b/c chrome does not allow testing a feature on a server that does not have a valid certificate, according to this website:
https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins

ISSUE 1: I get hundreds of this error on chrome: [.CommandBufferContext]RENDER WARNING: Render count or primcount is 0.
	I googled and one person suggested that it is caused due to having meshes with no vertices or faces, and suggested using a checkMesh code
	I used the checkMesh code but could not figure out what the problem is
	NOT SOLVED YET :(
	
ISSUE 2: each time that I update the circuit and the update code runs in three.js, there are a few errors:
	"Uncaught TypeError: Cannot read property 'updateElectron' of undefined"
	I need to modify my update() procedure to mitigate this issue!
	I tried adding a flag that when it is updating it does not render (and so update electrons) but it does not seem to work!
	SOLVED: I figured that the issue is happening when executing the doParse code, where it parses the circuit object after each update from parse
			so the solution is to setup a boolean (updateFlag) that becomes true when parsing (for update condition) starts, and ends when doUpdate()
			is called. This way, I don't get the error any longer :)
ISSUE 3: with accessing camera!
	SOLVED: the issue was simply with chrome deprecating features on insecure origins; so I had to use the localhost
	
	topcode opencv library
	websocket json
	camera angled from top: perspective correction
	magnetic helps with circuit configuration
	
*** notes on 4/12/2016

ISSUE 1: electrons not bouncing off the walls

ISSUE 2: size attenuation does not work for electrons

FINDING: I figured out that using revision r75 of three.js was not a good idea, and I have to switch it back to the older version:
		issues solved: 
		1. no more "the object cannot be linked to the inspector without the toolbox error"
		2. no more issue with electrons size attenuation
		3.
The changes that I needed to make in the code to go back to the older version:
	1. changed the address to the library: lib/three.js-r75/ --> lib/three.js/
	2. changed the particlesystem: points --> pointcloud
	3. changed loading the images function: THREE.TextureLoader().load( "textures/ball.png" ) --> THREE.ImageUtils.loadTexture( "textures/ball.png" );
	
*** notes on 4/15/2016	

ISSUE 1: why when I add an object without applying the jsar transformation matrices, it does not render it on the screen?

		It seems it is because of the camera, because the camera is not a perspective camera!!!
		
		

	
	