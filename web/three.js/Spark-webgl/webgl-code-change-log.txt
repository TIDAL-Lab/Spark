THINGS TO FIX LATER:
1. 

*** notes on 9/14/2015
1. I am studying how to run collision detection on particle systems. So far it seems that there is nothing good!
2. I am studying raycasters in three.js
3. I am changing the createContainer() function to createBox() function, the main change is that I am creating a 3D box instead of a 2D rectangle.
	And instead of actually drawing the box, I am creating a MESH using BoxGeometry(). 
	I also need to set the position and rotate the box so that it matches the coordinates of the input json object
4. I also am changing the start and end point objects to a bunch of Vector3() objects, I think this make thins easier later.
5. I made the component box transparent by adding:
	boxMaterial.transparent = true;
	boxMaterial.opacity = 0.5;
	But it did not work and it did not show the particles inside the box. I searched and added this line, which solved the problem:
	boxMaterial.depthWrite = false;
	
*** notes on 9/15/2015
1. Now it's time to work on collision detection!
2. Can I use boundingBox? 
	boundingBox = new THREE.Box3().setFromObject(boxMesh);
3. No! boundingBox is not the answer, because the box is parallel to the XYZ axes. 
4. I should define walls and use collision detection to the walls.

*** notes on 9/16/2015
1. Trying to rotate a geometry around a point that is external to the geometry --> to rotate the walls of component
	the solution is to append the walls to the component as its children and then rotate all of them at once
	component.add(walls[i]);
2. Now dealing with the raycaster and collision	
	For each electron I need to build a raycaster with electron's position and direction of moving, which is basically it's velocity vector.
3. For now, the electrons move randomly inside the box.
4. I made all the electrons moving with the same initial velocity, by changing random velocity.y to a value that results in a constant velocity 
	( velocity.y = sqrt(velocity-velocity.x^2) )
5. Now it's time to import the components from parse json object.

ADD LATER: change the bouncing off the walls
ADD LATER: add bumping into the ions!

*** notes on 9/16/2015
1. I added the code from old code that passes the json object of components to the webgl. I needed to make some little modifications in the code,
	including moving the js code from html file to the top of my main code. 
2. There are issues with when the parse code is called, which I'll fix later.
3. I fixed the problem with the coordinates, changing the code in "Circuit.dart" file, where it sends the json object.
	Before it was scaled to match the webgl format, but now I want the real position according to the center of working box.
4. ISSUE: not generating ions (SOLVED).
5. ISSUE: the component is rotated 90 degree on the XY plane (SOLVED).
6. ISSUE: the code stops when I change the circuit, any change (SOLVED).

*** notes on 9/17/2015
1. working on parsing code. Things to fix:
	* XY coordinates are not correct
	* run parse first, before making a change in the circuit.
	* there are no ions in the system now 
	* the code stops after making one change
2. I don't know what this is for: SyntaxError: unreachable code after return statement

*** notes on 9/21/2015
1. Today, I am trying to figure out how data streaming works in pubnub and parse.
2. I updated the JS Parse source, but then the execution gives error that Parse is not defined! I changed it back to the old one for now, to fix it later!
	For now, don't use the latest source!
3. I studies all the details about data streaming.
4. I created my own pubnub channel, and my own Parse app with my own account! All understood from Mmachi's code!
5. The components were not rotated by 90 degrees, the XY coordinates were set wrongly, which I fixed. Right now, the input coordinates in webgl are scaled up by x2
6. Warning Message: THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.
	---> NOT an issue for now, IGNORE it.
7. The issue with ions is solved. The issue was not with not generating ions, but with some scaling issue in the code that resulted in no ion to generate.

*** notes on 9/22/2015
1. Today, I am working on the issue that code stops rendering after I update the circuit. I am reading about requestAnimationFrame() method and how renderer works in WebGL.
2. I think at each update, I only need to remove objects from the scene, and add new objects to the scene.
3. YESSSSS! IT WORKED:
	I just needed to write an update() function, which only removes scene children and adds the updated objects to the scene.
4. ISSUE: with each update, electrons speed up! (SOLVED)
5. ISSUE: it is still not rendering correctly, some objects don't update correctly, some particles remain on canvas after the update, etc. 
	(SOLVED)
	Explanation: it was not corretcly removing the scene children, I used a wrong for loop.
	stackoverflow link that helped: http://stackoverflow.com/questions/29417374/threejs-remove-all-together-object-from-scene

6. I am working on camera, Z coordinate, and zooming in and zooming out
	I found a code online and added to my code, and now by mouse wheel, it zooms in/out.
	I used this link: http://stackoverflow.com/questions/10354574/webgl-zooming-camera-in-threejs-without-trackball-controls-or-other-camera-con
ISSUE: when it zooms in as much that the objects are out of scene, it cannot zoom out anymore!

*** notes on 9/23/2015
1. Solved the problem with electrons speeding up:
	Apparently, at each time that it was calling requestAnimationFrame( animate ), it was changing the time interval or something, 
	and as a result it was moving the particles faster (i.e., each update resulted in a shorter time step, and hence a faster particle)
	Solution was to only call render() function at each update, and not the whole animate() function.
2. I added a mouse drag functionality, by adding mouse up, mouse move, and mouse down functions. It now rotates the camera
	I originally wanted the mouse drag to drag the scene but it need more work later.
3. Working on collision with ions.
4. It seems that I have to change ions from being a particle system to an array of regular objects. It seems impossible to add the collision function if ions are particles.
	i.e., the raycaster only works with object3 structures, and the individual particles are not objects!
5. I changed the ion structure to become an array of ions as children of each component, so they are not pointcloud structure anymore.

*** notes on 9/24/2015
1. I studies how I can draw spheres for electrons, instead of using a ball texture. I haven't changed the code yet, but this link seems to show some good tricks, check it later:
http://stackoverflow.com/questions/12372834/rendering-spheres-or-points-in-a-particle-system
2. I added collision with ions
3. I added a tiny randomness in the bouncing back direction, but it still needs more work
4. I added a battery image texture to the battery and wrote a separate function for initializing the battery.
	
*** notes on 9/29/2015
1. Mike suggested that I don't use slice() method to select the electrons for each component (for the updateElectrons function).
	He thinks each time slice() is called, maybe it copies a whole array which can significantly slows down the execution. 
	Instead, I can pass the whole electrons array with start and end index to the updateElectron function.
	I did that, but I am not sure if I seen any obvious change in the speed of electrons moving.
2. I changed the structue of code, in a way that instead of assigning arrays of electrons to components in order, I create an ID field for each electron,
	which says which component it belongs to. This will make moving from one component to another easier later on.
	
*** notes on 9/30/2015	
1. Next project: Add junctions!
2. To avoid electrons flying off the component at reset: 
	I added a constant 5 to the calculated init coordination of electrons to avoid creating electrons right on the edge.
3. I also made the ion layout look a bit better!

*** notes on 10/6/2015
1. Since last week the code started crashing! Mike helped me run the code on Chrome using local server 127.0.0.1:3030
	But still the code crashes.
2. I am now trying to debug the issue. First, the crash was due to initing the code with two components initiated in the code
	and then when I update the circuit with Parse and data streaming, for some reason it crashes the code. 
	So for now, I commented the testing components and it directly initiates the circuit that is streamed from Parse.
3. Still the problem with updating speed is not solved. I submitted the code to gitub and am trying to compare it to the last commint to detect the source of issue.
4. I went through the code step by step and found out that the part that creates ions slows down the execution!!!
	*** the problem was that at each run of for loop for creating ions, the ionGeometry and ionMaterial were initialized too. 
		I movet it out of the loop, and the problem was solved :)
5. I fixed bouncing back code, using the face and normal property of the raycaster. The code is fixed for the ions, but still does not work for bouncing off the walls
	
*** notes on 10/7/2015
1. For some reason, bouncing back from the ions dramatically slows down the electrons. I need to troubleshoot it and find why! 	
	It also seems that the slowed down electron does not bounce off the ions anymore! (actually it is not always the case)
	Answer: the reflection is not working right. after bouncing back the z component of the velocity vector is not zero anymore, this explains both above observations!
2. ISSUE: the new bouncing back code still does not work for the walls, for some reason it detects a wrong face with a normal in z direction.
3. Now I am working on constructing a json object to send the information about connected components.
jsify():
https://api.dartlang.org/1.12.1/dart-js/JsObject/JsObject.jsify.html
create JSON by JS for loop:
http://stackoverflow.com/questions/920930/how-to-create-json-by-javascript-for-loop
4. I finished making the matrix in the dart code. the matrix encodes information about what components are connected and how (from s to e, from s to s, etc.)

*** notes on 10/8/2015
1. I need to flatten the connections array sent from Parse to the JS code.
Link to how to flatten a nested array: http://www.christopherbiscardi.com/2014/01/06/flattening-nested-arrays-in-javascript/
2. ISSUE: fix the bug with removing connected components!
3. ISSUE: fix the bug with reset button in Dart: not showing the battery when it is reset.
4. ISSUE: bouncing off the walls not working!


*** notes on 10/14/2015
Working on the Dart code to fix old issues (check dart code change log file)

*** notes on 10/15/2015
1. I tried to fix the issue with bouncing off the walls, apparently rotation the walls initially made the normal vectors working not as wanted
	(I still don't understand what is going on!!)
	But there is still issue with bouncing off the walls when the component is angled.
2. I modified bouncing off the ions, so that it considers the cases where the angle between electron velocity and normal vector is 180 or 90 degrees
	But still there are a rare cases where the electron stops moving when collide with an ion
	--> needs to be fixed!
	
*** notes on 10/19/2015
1. I have been working on the bounce back function which was not working correctly.
	The problem was with the local space and world space. For example, the electron velocity was in world space,
	but the face normals where in local space. The solution was to rotate the electron velocity with the reverse angle of component rotationAngle
	which makes the electron velocity in the component space, and then calculating the bounce back angle.
	
2. I commented the type check in the parse code, because it sorted the components base on types and then rendered them
	which messed up with reading the connected components!

*** notes on 10/22/2015
1. Working on making the junctions!
2. I wanted to have the electrons bounce off the box from inside. I searched and found this link helpful:
http://stackoverflow.com/questions/28664904/three-js-raycaster-collision-inside-of-cylinder
	The problem is solved by chanding the side of box to be rendered from front to back.
	